# -*- coding: utf-8 -*-
"""AQI.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DGAizCFIZ3P5Hs6RV1JT_eR2Et3UlTSc
"""

import os
import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt
import pickle
import warnings
warnings.filterwarnings("ignore")

from sklearn.preprocessing import LabelEncoder
file_path= r'C:\Users\Lange\Desktop\cpcb data\data1.xlsx'

df = pd.read_excel(file_path)

print(df.head())

df.rename(columns={'PM2.5':'PM2_5'},inplace=True)


df.info()

df.isnull().sum()

df['PM2_5']=pd.to_numeric(df['PM2_5'].astype(str), errors='coerce')
df['PM10']=pd.to_numeric(df['PM10'].astype(str), errors='coerce')
df['NO2']=pd.to_numeric(df['NO2'].astype(str), errors='coerce')
df['NH3']=pd.to_numeric(df['NH3'].astype(str), errors='coerce')
df['SO2']=pd.to_numeric(df['SO2'].astype(str), errors='coerce')
df['CO']=pd.to_numeric(df['CO'].astype(str), errors='coerce')
df['Ozone']=pd.to_numeric(df['Ozone'].astype(str), errors='coerce')

df

df.dtypes

df.info()

df.columns

df.describe()

sns.pairplot(df)

df['State'].value_counts()

plt.figure(figsize=(10,4))
plt.xticks(rotation=90)
df.State.hist()
plt.xlabel('State')
plt.ylabel('Frequencies')
plt.plot()

nullvalues=df.isnull().sum().sort_values(ascending=False)

nullvalues

null_values_percentage=(df.isnull().sum()/df.isnull().count()*100).sort_values(ascending=False)

#concatenating total null values and their percentage of missing values for further imputation or column deletion


missing_data_with_percentage=pd.concat([nullvalues,null_values_percentage],axis=1,keys=['Total','Percent'])

missing_data_with_percentage

df.fillna(0,inplace=True)

df

# Function to calculate pollutant index for PM2_5(Particular matter(pmsi))

def cal_pmsi(PM2_5):
  pmsi=0
  if(PM2_5<=30):
    pmsi= PM2_5*(50/30)
  elif(PM2_5>30 and PM2_5<=60):
    pmsi= 50+(PM2_5-30)*(50/30)
  elif(PM2_5>60 and PM2_5<=90):
    pmsi= 100+(PM2_5-60)*(100/30)
  elif(PM2_5>90 and PM2_5<=120):
    pmsi= 200+(PM2_5-90)*(100/30)
  elif(PM2_5>120 and PM2_5<=250):
    pmsi= 300+(PM2_5-120)*(100/130)
  else:
    pmsi= 400+(PM2_5-250)*(100/100)
  return pmsi
df['pmsi']=df['PM2_5'].apply(cal_pmsi)
data=df[['PM2_5','pmsi']]
data

# Function to calculate individual pollutant index for PM10(Particular matter10(pmli))


def cal_pmli(PM10):
  pmli=0
  if(PM10<=50):
    pmli= PM10*(50/50)
  elif(PM10>50 and PM10<=100):
    pmli= 50+(PM10-50)*(50/50)
  elif(PM10>100 and PM10<=250):
    pmli= 100+(PM10-100)*(100/150)
  elif(PM10>250 and PM10<=350):
    pmli= 200+(PM10-250)*(100/100)
  elif(PM10>350 and PM10<=430):
    pmli= 300+(PM10-350)*(100/80)
  else:
    pmli= 400+(PM10-430)*(100/70)
  return pmli
df['pmli']=df['PM10'].apply(cal_pmli)
data=df[['PM10','pmli']]
data

# Function to calculate individual pollutant index for NO2(nitrogen dioxide(ni))

def cal_NOi(NO2):
  ni=0
  if(NO2<=40):
    ni= NO2*(50/40)
  elif(NO2>40 and NO2<=80):
    ni= 50+(NO2-40)*(50/40)
  elif(NO2>80 and NO2<=180):
    ni= 100+(NO2-80)*(100/100)
  elif(NO2>180 and NO2<=280):
    ni= 200+(NO2-180)*(100/100)
  elif(NO2>280 and NO2<=400):
    ni= 300+(NO2-280)*(100/120)
  elif(NO2>400):
    ni= 400+(NO2-400)*(100/100)
  return ni
df['NOi']=df['NO2'].apply(cal_NOi)
data=df[['NO2','NOi']]
data

# Function to calculate individual pollutant index for NH3(ammonia(NHi))

def cal_NHi(NH3):
  NHi=0
  if(NH3<=200):
    NHi= NH3*(50/200)
  elif(NH3>200 and NH3<=400):
    NHi= 50+(NH3-200)*(50/200)
  elif(NH3>400 and NH3<=800):
    NHi= 100+(NH3-400)*(100/400)
  elif(NH3>800 and NH3<=1200):
    NHi= 200+(NH3-800)*(100/400)
  elif(NH3>1200 and NH3<=1800):
    NHi= 300+(NH3-1200)*(100/600)
  elif(NH3>1800):
    NHi= 400+(NH3-1800)*(100/100)
  return NHi
df['NHi']=df['NH3'].apply(cal_NHi)
data=df[['NH3','NHi']]
data

# Function to calculate pollutant index for SO2(sulphur dioxide(si))

def cal_SOi(SO2):
  si=0
  if(SO2<=40):
    si= SO2*(50/40)
  elif(SO2>40 and SO2<=80):
    si= 50+(SO2-40)*(50/40)
  elif(SO2>80 and SO2<380):
    si= 100+(SO2-80)*(100/300)
  elif(SO2>380 and SO2<=800):
    si= 200+(SO2-380)*(100/420)
  elif(SO2>800 and SO2<=1600):
    si= 300+(SO2-800)*(100/800)
  elif(SO2>1600):
    si= 400+(SO2-1600)*(100/100)
  return si
df['SOi']=df['SO2'].apply(cal_SOi)
data=df[['SO2','SOi']]
data

# Function to calculate pollutant index for CO(carbon monoxide(coi))

def cal_COi(CO):
  COi=0
  if(CO<=1):
    COi= CO*(50)
  elif(CO>1 and CO<=2):
    COi= 50+(CO-1)*(50)
  elif(CO>2 and CO<=10):
    COi= 100+(CO-2)*(100/8)
  elif(CO>10 and CO<=17):
    COi= 200+(CO-10)*(100/7)
  elif(CO>17 and CO<=34):
    COi= 300+(CO-17)*(100/17)
  elif(CO>34):
    COi= 400+(CO-34)*(100/34)
  return COi
df['COi']=df['CO'].apply(cal_COi)
data=df[['CO','COi']]
data

# Function to calculate pollutant index for O3(OzoneOi))

def cal_Oi(Ozone):
  Oi=0
  if(Ozone<=50):
    Oi= Ozone*(1)
  elif(Ozone>50 and Ozone<=100):
    Oi= 50+(Ozone-50)*(50/50)
  elif(Ozone>100 and Ozone<=168):
    Oi= 100+(Ozone-100)*(100/68)
  elif(Ozone>168 and Ozone<=208):
    Oi= 200+(Ozone-380)*(100/40)
  elif(Ozone>208 and Ozone<=748):
    Oi= 300+(Ozone-208)*(100/540)
  elif(Ozone>748):
    Oi= 400+(Ozone-748)*(100/748)
  return Oi
df['Oi']=df['Ozone'].apply(cal_Oi)
data=df[['Ozone','Oi']]
data

df.drop(['From Date'],axis=1,inplace=True)
df.drop(['To Date'],axis=1,inplace=True)

df

# Function to calculate air quality index(AQI) of every data value

def cal_aqi(pmsi,pmli,NOi,NHi,SOi,COi,Oi):
  aqi=0
  if(pmsi>pmli and pmsi>NOi and pmsi>NHi and pmsi>SOi and pmsi>COi and pmsi>Oi):
    aqi=pmsi
  if(pmli>pmsi and pmli>NOi and pmli>NHi and pmli>SOi and pmli>COi and pmli>Oi):
    aqi=pmli
  if(NOi>pmsi and NOi>pmli and NOi>NHi and NOi>SOi and NOi>COi and NOi>Oi):
    aqi=NOi
  if(NHi>pmsi and NHi>pmli and NHi>NOi and NHi>SOi and NHi>COi and NHi>Oi):
    aqi=NHi
  if(SOi>pmsi and SOi>pmli and SOi>NOi and SOi>NHi and SOi>COi and SOi>Oi):
    aqi=SOi
  if(COi>pmsi and COi>pmli and COi>NOi and COi>NHi and COi>SOi and COi>Oi):
    aqi=COi
  if(Oi>pmsi and Oi>pmli and Oi>NOi and Oi>NHi and Oi>SOi and Oi>COi):
     aqi=Oi
  return aqi

df['AQI']=df.apply(lambda x:cal_aqi(x['pmsi'],x['pmli'],x['NOi'],x['NHi'],x['SOi'],x['COi'],x['Oi']),axis=1)
data=df[['State','pmsi','pmli','NOi','NHi','SOi','COi','Oi','AQI']]
data

plt.rcParams['figure.figsize']=(24,8)

df[['AQI','State']].groupby(["State"]).mean().sort_values(by='AQI').plot.bar(color='blue')
plt.show()

df[['pmli','State']].groupby(["State"]).mean().sort_values(by='pmli').plot.bar(color='blue')
plt.show()

df[['pmsi','State']].groupby(["State"]).mean().sort_values(by='pmsi').plot.bar(color='blue')
plt.show()

df[['NOi','State']].groupby(["State"]).mean().sort_values(by='NOi').plot.bar(color='blue')
plt.show()

df[['NHi','State']].groupby(["State"]).mean().sort_values(by='NHi').plot.bar(color='blue')
plt.show()

df[['SOi','State']].groupby(["State"]).mean().sort_values(by='SOi').plot.bar(color='blue')
plt.show()

df[['COi','State']].groupby(["State"]).mean().sort_values(by='COi').plot.bar(color='blue')
plt.show()

df[['Oi','State']].groupby(["State"]).mean().sort_values(by='Oi').plot.bar(color='blue')
plt.show()

"""*Splitting dataset into denpendent and independent column*"""

X=df[['pmsi','pmli','NOi','NHi','SOi','COi','Oi']]
Y=df['AQI']


"""*Machine learning Models to train and test data*"""

from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn import metrics
from sklearn.metrics import mean_squared_error,r2_score
import pickle


# splitting the data into traning and testing data

X_train,X_test,Y_train,Y_test=train_test_split(X,Y,test_size=0.2,random_state=70)
print(X_train.shape,X_test.shape,Y_train.shape,Y_test.shape)


# Randon Forest Regressor


Regressor=RandomForestRegressor()

Regressor.fit(X_train,Y_train)

# predicting on train
train_pred=Regressor.predict(X_train)

# predicting on test
test_pred=Regressor.predict(X_test)


RMSE_train=(np.sqrt(metrics.mean_squared_error(Y_train,train_pred)))
RMSE_test=(np.sqrt(metrics.mean_squared_error(Y_test,test_pred)))
print("RSME TraningData= ",str(RMSE_train))
print("RSME TestData= ",str(RMSE_test))
print('-'*50)
print('RSquared value on train:',Regressor.score(X_train,Y_train))
print('RSquared value on test:',Regressor.score(X_test,Y_test))

#pickle file for model
pickle.dump(Regressor, open("Model.pkl","wb"))

# Regressor.predict([[20.5,2.4,14.8,25.8,8.8,9.5,4.5]])
